import getPopperClientRect from '../utils/getPopperClientRect';
import getOppositePlacement from '../utils/getOppositePlacement';
import getOffsetParent from '../utils/getOffsetParent';
import getBoundaries from '../utils/getBoundaries';

/**
 * Modifier used to make sure the popper does not overflows from it's boundaries
 * @method
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
export default function preventOverflow(data, options) {
    function shouldNotMoveWithTarget(direction) {
        if (!options.moveWithTarget) {
            return true;
        }
        const placement = data.originalPlacement.split('-')[0];

        if (data.flipped && placement === direction || placement === getOppositePlacement(direction)) {
            return false;
        }
        if (placement !== direction && placement !== getOppositePlacement(direction)) {
            return false;
        }

        return true;
    }
    const order = options.priority;
    const popper = getPopperClientRect(data.offsets.popper);

    const check = {
        left() {
            let left = popper.left;
            if (popper.left < options.boundaries.left && shouldNotMoveWithTarget('left')) {
                left = Math.max(popper.left, options.boundaries.left);
            }
            return { left: left };
        },
        right() {
            let left = popper.left;
            if (popper.right > options.boundaries.right && shouldNotMoveWithTarget('right')) {
                left = Math.min(popper.left, options.boundaries.right - popper.width);
            }
            return { left: left };
        },
        top() {
            let top = popper.top;
            if (popper.top < options.boundaries.top && shouldNotMoveWithTarget('top')) {
                top = Math.max(popper.top, options.boundaries.top);
            }
            return { top: top };
        },
        bottom() {
            let top = popper.top;
            if (popper.bottom > options.boundaries.bottom && shouldNotMoveWithTarget('bottom')) {
                top = Math.min(popper.top, options.boundaries.bottom - popper.height);
            }
            return { top: top };
        }
    };

    order.forEach((direction) => {
        data.offsets.popper = Object.assign(
            popper,
            check[direction]()
        );
    });

    return data;
}

export function preventOverflowOnLoad(reference, popper, options, modifierOptions) {
    const padding = modifierOptions.padding;
    const boundariesElement = modifierOptions.boundariesElement || getOffsetParent(popper);
    const scrollParentRect = getBoundaries(popper, padding, boundariesElement);

    modifierOptions.boundaries = scrollParentRect;
}
